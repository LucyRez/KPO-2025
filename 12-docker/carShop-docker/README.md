# Занятие 12. Docker

## Теория

Docker - это инструмент для автоматизации развертывания приложений.

Docker используется для создания контейнеров, которые могут быть запущены на любой машине, поддерживающей Docker.

Контейнеры отличаются от виртуальных машин тем, что они не изолируют операционную систему, а только приложение. Такую виртуализацию также называются виртуализацией уровня ядра ОС - в этом случае ядро ОС и сама ОС остаются в неизменном виде, а приложение запускается в изолированном контейнере отдельно от остальных приложений. Также такую виртуализацию называют контейнеризацией.

Контейнеризация может применяться как для развертывания самих приложений, так и ресурсов, необходимых для их работы (базы данных, брокеры сообщений, кеши и т.д.).

## Практика

В текущем занятии мы рассмотрим, как можно использовать Docker для:

- Развертывания базы данных;
- Развертывания приложения.

На данном занятии мы не будем рассматривать процесс настройки и установки Docker, так как он зависит от конкретной операционной системы. Гайды для этого можно найти в сети Интернет.

### Развертывание базы данных

Начнем с развертывания базы данных. В качестве базы данных мы будем использовать PostgreSQL.

Для развертывания базы данных мы будем использовать Docker Compose.

Docker Compose - это инструмент для запуска мультиконтейнерных приложений. Он позволяет задать все необходимые параметры для запуска каждого из контейнеров в виде конфигурационного файла.

Создадим файл `docker-compose.yml` в корне проекта и добавим в него следующий код:

```yaml
version: '3'
services:
  postgres:
    image: postgres:13
    ports:
      - "5432:5432"
    environment:
      POSTGRES_PASSWORD: car-shop-db-pass
      POSTGRES_DB: car-shop-db
      POSTGRES_USER: car-shop-db
```

В этом файле мы описали один контейнер под названием `postgres`, который будет использовать образ `postgres` версии `13`. 

Внутри контейнера будет создана база данных `car-shop-db` с пользователем `car-shop-db` и паролем `car-shop-db-pass`.

Также мы настроили настроили контейнер таким образом, чтобы он был доступен по порту `5432` нашего компьютера.

Теперь мы можем запустить контейнер, открыв терминал в том же каталоге, где находится файл `docker-compose.yml`, и выполнив команду:

```bash
docker compose up postgres -d
```

После этого мы можем проверить, что контейнер запущен, выполнив команду:

```bash
docker ps
```

Чтобы подключиться к базе данных, можно использовать любой SQL клиент. Например, DBeaver или pgAdmin.

Для подключения к базе данных в DBeaver нужно ввести следующие параметры:

- Хост: `localhost`
- Порт: `5432`
- База данных: `car-shop-db`
- Пользователь: `car-shop-db`
- Пароль: `car-shop-db-pass`

После этого можно будет просматривать и изменять данные в базе данных.

### Замена SQLite на PostgreSQL

Теперь мы можем заменить SQLite на PostgreSQL в нашем проекте. Начнем с замены NuGet пакета `Microsoft.EntityFrameworkCore.Sqlite` на `Microsoft.EntityFrameworkCore.Npgsql`.

Для этого переходим в каталог с инфраструктурным проектом и выполняем последовательно следующие команды:

```bash
dotnet remove package Microsoft.EntityFrameworkCore.Sqlite
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL --version 8
```

При помощи первой команды мы удалили поддержку SQLite из проекта, а при помощи второй - добавили поддержку PostgreSQL.

Далее нам необходимо изменить код настройки контекста базы данных. Для этого переходим в класс ServiceCollectionExtensions инфраструктурного проекта и заменяем строки:

```csharp
services.AddDbContext<AppDbContext>(options =>
{
    options.UseSqlite("Data Source=UniversalCarShop.db");
});
```

на следующие строки:

```csharp
services.AddDbContext<AppDbContext>((serviceProvider, options) =>
{
    var configuration = serviceProvider.GetRequiredService<IConfiguration>();
    var connectionString = configuration.GetConnectionString("PostgreSQL");

    options.UseNpgsql(connectionString);
});
```

Новые строки обозначают следующее:

- Мы получаем конфигурацию приложения из DI контейнера;
- Из конфигурации получаем строку подключения к базе данных;
- Используем полученную строку подключения для настройки подключения к PostgreSQL.

Также необходимо обновить класс `DesignTimeDbContextFactory` в инфраструктурном проекте. Для этого переходим в класс и заменяем строку:

```csharp
optionsBuilder.UseSqlite("Data Source=UniversalCarShop.db");
```

на следующую:

```csharp
optionsBuilder.UseNpgsql();
```

Далее обновляем код репозиториев в инфраструктурном проекте. Для этого ищем в репозиториях вызов `AsEnumerable()` и заменяем его на вызов `ToList()`, так как использование первого в некоторых случаях
может приводить к ошибкам при использовании PostgreSQL.

Теперь нам необходимо перегенерировать миграции, так как они были созданы для SQLite. Для этого удаляем каталог `Migrations` в инфраструктурном проекте и выполняем команду:

```bash
dotnet ef migrations add InitialCreate
```

Теперь добавим строку подключения к базе данных в файл `appsettings.json` приложения. Для этого переходим в каталог с приложением и добавляем следующие строки:

```json
"ConnectionStrings": {
  "PostgreSQL": "Host=localhost;Database=car-shop-db;Username=car-shop-db;Password=car-shop-db-pass"
}
```

Теперь запустим приложение и проверим, что оно работает с PostgreSQL. Для этого перейдем в каталог с проектом Web-приложения и выполним команду:

```bash
dotnet run
```

Когда приложение соберется и запустится, используем выбранный нами SQL-клиент для подключения к базе данных и проверяем, что в базе данных появились все таблицы, необходимые для работы приложения. Это будет означать, что мы успешно заменили SQLite на PostgreSQL.

### Упаковка приложения в Docker

Перед тем, как развернуть приложение, его нужно упаковать в контейнер.

Для этого нам нужно создать Dockerfile.

Dockerfile - это файл, который содержит инструкции для сборки и запуска контейнера.

Каждая инструкция в Dockerfile создает новый слой в контейнере. Слой - это, если говорить простым языком, версия файловой системы контейнера. В качестве аналогии можно привести коммиты в git.

Каждый коммит создает новую версию файловой системы, но при этом сохраняет все предыдущие версии. Также и в Docker, каждый слой создает новую версию файловой системы, но при этом сохраняет все предыдущие версии.

Данный механизм позволяет оптимизировать процесс сборки и запуска контейнера, так как при сборке контейнера Docker использует кэширование слоев.

Создадим файл `Dockerfile` в корне проекта и добавим в него следующий код:

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

COPY ["UniversalCarShop.Entities/UniversalCarShop.Entities.csproj", "UniversalCarShop.Entities/"]
COPY ["UniversalCarShop.Infrastructure/UniversalCarShop.Infrastructure.csproj", "UniversalCarShop.Infrastructure/"]
COPY ["UniversalCarShop.UseCases/UniversalCarShop.UseCases.csproj", "UniversalCarShop.UseCases/"]
COPY ["UniversalCarShop.Web/UniversalCarShop.Web.csproj", "UniversalCarShop.Web/"]

RUN dotnet restore "UniversalCarShop.Web/UniversalCarShop.Web.csproj"
```

Рассмотрим каждую строку по порядку. 

Первая строка определяет, что для сборки нашего проекта мы будем использовать контейнер под названием `build`, а также указывает, на основе какого образа будет создаваться контейнер. В данном случае это образ .NET SDK версии 8.0.

Вторая строка устанавливает рабочую директорию для сборки приложения. Это директория внутри контейнера и она необязательно должна совпадать с директорией на вашем компьютере.

Следующие строки копируют файлы проектов в контейнер.

Последняя строка восстанавливает зависимости проекта.

Обратите внимание, что мы копируем только файлы `csproj`, так как для восстановления зависимостей достаточно только этих файлов. Это делается для того, чтобы ускорить последующие операции сборки контейнера, так как,
как было сказано ранее, Docker использует кеширование слоев и пока наш список зависимостей не поменяется - результат восстановления зависимостей будет браться из кэша.

Далее добавим следующие строки:

```dockerfile
COPY . .

WORKDIR "/src/UniversalCarShop.Web"

RUN dotnet publish -c Release -o /out
```

Первая строка копирует все файлы проекта в контейнер. Так как здесь мы копируем все файлы, то последующие шаги будут уже выполняться каждый раз, когда поменяется какой-либо файл в проекте.

Вторая строка устанавливает рабочую директорию для сборки приложения.

Последняя строка выполняет сборку проекта внутри контейнера.

Теперь добавим следующие строки:

```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS publish
WORKDIR /app
COPY --from=build /out .
ENTRYPOINT ["dotnet", "UniversalCarShop.Web.dll"]
```

Первая строка определяет, что для запуска приложения мы будем использовать контейнер под названием `publish`, а также указывает, на основе какого образа будет создаваться контейнер. В данном случае это образ .NET Runtime версии 8.0.

Вторая строка устанавливает рабочую директорию для запуска приложения.

Третья строка копирует результат сборки приложения из контейнера с названием `build` в контейнер с названием `publish`.

Последняя строка запускает приложение.

Теперь мы можем попробовать собрать контейнер. Для этого перейдем в каталог, где расположен файл `Dockerfile`, и выполним команду:

```bash
docker build -t universal-car-shop .
```

Если все было выполнено правильно, то данная команда выдаст ошибку, так как наш инфраструктурный проект ссылается на `ReportServer.Client`, который мы не скопировали в контейнер во время сборки.

Загвоздка состоит в том, что даже если мы сейчас добавим инструкцию вроде `COPY ../../../misc/ReportServer/ReportServer.Client ./ReportServer.Client`, то это не решит проблему, так как система сборки умеет работать только с файлами в том каталоге,
который используется в качестве директории для сборки, а в нашем случае это директория нашего решения.

Поэтому для решения проблемы для начала скопируем проект `ReportServer.Client` в директорию нашего решения и поменяем ссылку в нашем инфраструктурном проекте таким образом, чтобы он ссылался на скопированный проект.

Так как у нас добавился новый проект, то добавим копирование нового файла `csproj` в наш Dockerfile в соответствующую секцию:

```dockerfile
COPY ["ReportServer.Client/ReportServer.Client.csproj", "ReportServer.Client/"]
```

Теперь снова попробуем собрать контейнер, выполнив команду:

```bash
docker build -t universal-car-shop .
```

Теперь сборка должна пройти успешно.

### Развертывание приложения в Docker

Теперь мы можем развернуть приложение в Docker. Добавим в наш файл `docker-compose.yml` строки:

```yaml
# ...существующие строки...
  universal-car-shop:
    image: universal-car-shop
    ports:
      - "8080:8080"
    depends_on:
      - postgres
    environment:
      CONNECTIONSTRINGS__PostgreSQL: Host=postgres;Database=car-shop-db;Username=car-shop-db;Password=car-shop-db-pass
      ASPNETCORE_ENVIRONMENT: Development
```

При помощи данных строк мы добавляем контейнер `universal-car-shop`, который будет использовать образ `universal-car-shop`, который мы собрали ранее.

Также мы настраиваем порт, на котором будет доступно наше приложение, и указываем, что контейнер зависит от контейнера `postgres`.

Наконец, мы добавляем переменную окружения, которая будет содержать строку подключения к базе данных. Здесь стоит обратить внимание, что вместо `localhost` мы используем `postgres`,
так как Docker Compose создает сеть между контейнерами и позволяет обращаться к ним по имени контейнера.

Также мы указываем, что окружение, в котором будет запущено приложение - это окружение разработки. Это нужно для того, чтобы мы могли использовать Swagger.

Теперь мы можем запустить приложение, выполнив команду:

```bash
docker compose up
```

При этом Docker Compose автоматически запустит все необходимые контейнеры и подключит их друг к другу.

Теперь мы можем открыть браузер и перейти на страницу `http://localhost:8080/swagger/index.html`, чтобы использовать Swagger и проверить, что приложение работает.
